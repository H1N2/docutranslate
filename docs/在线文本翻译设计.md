# 在线文本翻译功能设计方案

## 1. 目标与范围
- 目标：在 Web UI 中提供“输入框 + 翻译按钮”，将用户输入的**短文本段落**在线翻译为目标语言。
- 范围：仅非文件型输入；**仅支持非流式返回**。
- 约束：沿用现有 LLM 配置模型；尽量复用 `TXTTranslatorConfig` 与导出器；避免侵入工作流主路径。

## 2. 用户体验（UI）
- 位置：新增独立页面 `static/text.html`；在首页 `static/index.html` 顶部增加**入口链接**，`text.html` 页面顶部提供**返回首页**链接。
- 元素：
  - 文本编辑框：多行输入（placeholder：粘贴待翻译文本）。
  - 目标语言下拉框：默认 `Chinese`（或跟随系统语言）。
  - LLM 配置输入：`base_url`、`api_key`、`model_id`（复用页面已有设置或在独立页提供简单输入）。
  - 按钮：`翻译`（非流式）。
  - 输出区：显示译文，支持复制按钮。
- 交互：
  - 点击翻译后禁用按钮与输入框，显示进度；返回结果后恢复。
  - 错误提示：API 失败时在输出区显示简明错误（含重试建议）。

## 3. 后端接口设计（FastAPI）

### 3.1 非流式翻译
- 路径：`POST /service/translate_text`
- Request（JSON）：
```json
{
  "text": "string",
  "to_lang": "Chinese",
  "translator": {
    "base_url": "https://api.openai.com/v1/",
    "api_key": "***",
    "model_id": "gpt-4o",
    "chunk_size": 2000,
    "concurrent": 4
  }
}
```
- Response（JSON）：
```json
{
  "ok": true,
  "translated": "目标语言文本",
  "usage": {"segments": 1, "duration_ms": 1234}
}
```
- 语义：一次性返回完整译文；适合短文本与复制粘贴。

（流式与 WebSocket 已取消，不在本方案范围内。）

## 4. 核心类与实现策略

### 4.1 复用 translator 配置
- 使用 `docutranslate.translator.ai_translator.txt_translator.TXTTranslatorConfig` 以保持一致的参数语义。
- 调度逻辑独立于工作流，避免为一段文本构造完整 `Workflow`。

### 4.2 轻量调度器
- 新增 `TextTranslateService`（函数式或小类）封装：
  - 入参：`text`、`to_lang`、`TXTTranslatorConfig`。
  - 过程：按照分块策略（`chunk_size`）切分文本，异步并发请求 LLM（`concurrent`），拼接结果。
  - 可选：术语表开关与字典应用（与 `GlossaryAgentConfig` 对齐）。

（已移除流式实现，统一使用非流式一次性返回。）

## 5. 前端改动（`static/index.html` & `static/autoRender.js`）

### 5.1 UI 结构（示例片段）
```html
<!-- 在线文本翻译 -->
<section id="online-translate" class="card">
  <header>在线文本翻译</header>
  <textarea id="ot-input" rows="8" placeholder="粘贴待翻译文本..."></textarea>
  <div class="grid">
    <input id="ot-to-lang" placeholder="目标语言，如 Chinese" />
    <button id="ot-btn">翻译</button>
    <button id="ot-btn-stream">流式翻译</button>
  </div>
  <pre id="ot-output" class="result"></pre>
</section>
```

### 5.2 JS 逻辑（必要中文注释）
```js
// =============================
// 在线文本翻译（非流式示例）
// =============================
async function translateTextOnce() {
  const text = document.getElementById('ot-input').value.trim();
  const toLang = document.getElementById('ot-to-lang').value.trim() || 'Chinese';
  const output = document.getElementById('ot-output');
  output.textContent = '翻译中...';
  const cfg = getLLMConfigFromUI(); // 复用已有 LLM 配置获取函数
  const resp = await fetch('/service/translate_text', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({text, to_lang: toLang, translator: cfg})
  });
  if (!resp.ok) { output.textContent = '请求失败'; return; }
  const data = await resp.json();
  output.textContent = data.translated || '无内容';
}
```

## 6. 分块、并发与限流
- 分块：按 `chunk_size` 对文本进行自然边界（句子/段落）切分；不足一块直接翻译。
- 并发：控制并发 `concurrent`，避免打爆配额；按序合并结果。
- 防抖：UI 端对输入框加防抖（如 500ms）避免频繁调用。
- 限流：后端对单 IP/用户做速率限制（如 `n requests/min`）。

## 7. 缓存与去重
- 内容散列为键（`sha256(text+to_lang+model_id)`）；命中返回最近结果。
- UI 端本地缓存最近 10 条；便于回溯与复用。

## 8. 错误边界与提示
- 分类：鉴权错误（key 不合法）、配额超限、网络/超时、模型不可用。
- 返回：统一 `{"ok": false, "error": "..."}`；SSE 用 `event:error`。
- 前端提示：简明错误 + 重试/更换模型建议；保留输入内容。

## 9. 安全与隐私
- 不持久化用户输入；仅在内存处理与可选短期缓存。
- 对 API Key 做最小化校验与遮蔽；避免日志泄露。

## 10. 兼容与扩展
- 兼容已有 LLM 提供商；不绑定特定平台。
- 可扩展到多语多区域（UI 增加 `from_lang` 与自动检测）。

## 11. 实现步骤（迭代计划）
1. 后端：在 `app.py` 新增 `POST /service/translate_text`（非流式）。
2. 前端：新增独立页面 `static/text.html`；在首页 `static/index.html` 顶部添加“在线文本翻译”入口链接；独立页顶部提供“返回首页”链接。
3. 并发与分块：实现基础分块器与顺序合并；引入简单速率限制。
4. 缓存：内存 LRU（最多 100 条，过期 10 分钟）。
5. 验证：端到端手测 + 文档补充（用户手册新增在线翻译章节）。

## 12. 代码哲学与品味自检
- 消除特殊分支：通过 `*Config` 组合而不是在函数里 `if/else` 拼接。
- 小函数单一职责：分块、并发调度、SSE 写流各自独立。
- 缩进不超过 3 层：流式处理用早返回与小型辅助函数。

## 13. 验收标准
- UI 可用：输入文本点击“翻译”得到正确结果；独立页具备返回首页与入口链接。
- 后端稳健：错误边界清晰；日志可追踪。
- 文档齐备：使用指南、API 示例与限制已明确。